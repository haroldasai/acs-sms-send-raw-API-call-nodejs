// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __awaiter } from "tslib";
import { URLBuilder, isNode, BaseRequestPolicy } from "@azure/core-http";
import { shaHash, shaHMAC } from "./cryptoUtils";
/**
 * Creates an HTTP pipeline policy to authenticate a request using a `KeyCredential`.
 * @hidden
 *
 * @param credential - The key credential.
 */
export const createCommunicationAccessKeyCredentialPolicy = (credential) => {
    return {
        create: (nextpolicy, options) => {
            return new CommunicationAccessKeyCredentialPolicy(credential, nextpolicy, options);
        }
    };
};
/**
 * CommunicationAccessKeyCredentialPolicy provides a means of signing requests made through
 * the SmsClient.
 */
class CommunicationAccessKeyCredentialPolicy extends BaseRequestPolicy {
    /**
     * Initializes a new instance of the CommunicationAccessKeyCredential class
     * using a base64 encoded key.
     * @param accessKey - The base64 encoded key to be used for signing.
     */
    constructor(accessKey, nextPolicy, options) {
        super(nextPolicy, options);
        this.accessKey = accessKey;
    }
    /**
     * Signs a request with the provided access key.
     *
     * @param webResource - The WebResource to be signed.
     */
    signRequest(webResource) {
        return __awaiter(this, void 0, void 0, function* () {
            const verb = webResource.method.toUpperCase();
            const utcNow = new Date().toUTCString();
            const contentHash = yield shaHash(webResource.body || "");
            const dateHeader = isNode ? "date" : "x-ms-date";
            const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;
            const url = URLBuilder.parse(webResource.url);
            const query = url.getQuery();
            const urlPathAndQuery = query ? `${url.getPath()}?${query}` : url.getPath();
            const port = url.getPort();
            const hostAndPort = port ? `${url.getHost()}:${port}` : url.getHost();
            const stringToSign = `${verb}\n${urlPathAndQuery}\n${utcNow};${hostAndPort};${contentHash}`;
            const signature = yield shaHMAC(this.accessKey.key, stringToSign);
            if (isNode) {
                webResource.headers.set("Host", hostAndPort || "");
            }
            webResource.headers.set(dateHeader, utcNow);
            webResource.headers.set("x-ms-content-sha256", contentHash);
            webResource.headers.set("Authorization", `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`);
            return webResource;
        });
    }
    /**
     * Signs the request and calls the next policy in the factory.
     */
    sendRequest(webResource) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!webResource) {
                throw new Error("webResource cannot be null or undefined");
            }
            return this._nextPolicy.sendRequest(yield this.signRequest(webResource));
        });
    }
}
//# sourceMappingURL=communicationAccessKeyCredentialPolicy.js.map