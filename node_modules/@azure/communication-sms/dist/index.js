'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var communicationCommon = require('@azure/communication-common');
var coreHttp = require('@azure/core-http');
var api = require('@opentelemetry/api');
var coreTracing = require('@azure/core-tracing');
var logger$1 = require('@azure/logger');

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const SendMessageRequest = {
    type: {
        name: "Composite",
        className: "SendMessageRequest",
        modelProperties: {
            from: {
                serializedName: "from",
                required: true,
                type: {
                    name: "String"
                }
            },
            smsRecipients: {
                serializedName: "smsRecipients",
                required: true,
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "SmsRecipient" } }
                }
            },
            message: {
                constraints: {
                    MaxLength: 2048
                },
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            smsSendOptions: {
                serializedName: "smsSendOptions",
                type: {
                    name: "Composite",
                    className: "SmsSendOptions"
                }
            }
        }
    }
};
const SmsRecipient = {
    type: {
        name: "Composite",
        className: "SmsRecipient",
        modelProperties: {
            to: {
                serializedName: "to",
                required: true,
                type: {
                    name: "String"
                }
            },
            repeatabilityRequestId: {
                serializedName: "repeatabilityRequestId",
                type: {
                    name: "String"
                }
            },
            repeatabilityFirstSent: {
                serializedName: "repeatabilityFirstSent",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SmsSendOptions = {
    type: {
        name: "Composite",
        className: "SmsSendOptions",
        modelProperties: {
            enableDeliveryReport: {
                serializedName: "enableDeliveryReport",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            tag: {
                serializedName: "tag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SmsSendResponse = {
    type: {
        name: "Composite",
        className: "SmsSendResponse",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "SmsSendResponseItem" }
                    }
                }
            }
        }
    }
};
const SmsSendResponseItem = {
    type: {
        name: "Composite",
        className: "SmsSendResponseItem",
        modelProperties: {
            to: {
                serializedName: "to",
                required: true,
                type: {
                    name: "String"
                }
            },
            messageId: {
                serializedName: "messageId",
                type: {
                    name: "String"
                }
            },
            httpStatusCode: {
                serializedName: "httpStatusCode",
                required: true,
                type: {
                    name: "Number"
                }
            },
            repeatabilityResult: {
                serializedName: "repeatabilityResult",
                type: {
                    name: "String"
                }
            },
            successful: {
                serializedName: "successful",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    SendMessageRequest: SendMessageRequest,
    SmsRecipient: SmsRecipient,
    SmsSendOptions: SmsSendOptions,
    SmsSendResponse: SmsSendResponse,
    SmsSendResponseItem: SmsSendResponseItem
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const sendMessageRequest = {
    parameterPath: "sendMessageRequest",
    mapper: SendMessageRequest
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-03-07",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/**
 * Class representing a Sms.
 */
class Sms {
    /**
     * Initialize a new instance of the class Sms class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Sends a SMS message from a phone number that belongs to the authenticated account.
     * @param sendMessageRequest Represents the body of the send message request.
     * @param options The options parameters.
     */
    send(sendMessageRequest, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ sendMessageRequest, options: operationOptions }, sendOperationSpec);
    }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);
const sendOperationSpec = {
    path: "/sms",
    httpMethod: "POST",
    responses: {
        202: {
            bodyMapper: SmsSendResponse
        }
    },
    requestBody: sendMessageRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [contentType],
    mediaType: "json",
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const packageName = "azure-communication-sms";
const packageVersion = "1.0.0";
class SmsApiClientContext extends coreHttp.ServiceClient {
    /**
     * Initializes a new instance of the SmsApiClientContext class.
     * @param endpoint The communication resource, for example https://my-resource.communication.azure.com
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            const defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;
        }
        super(undefined, options);
        this.requestContentType = "application/json; charset=utf-8";
        this.baseUri = options.endpoint || "{endpoint}";
        // Parameter assignments
        this.endpoint = endpoint;
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "2021-03-07";
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class SmsApiClient extends SmsApiClientContext {
    /**
     * Initializes a new instance of the SmsApiClient class.
     * @param endpoint The communication resource, for example https://my-resource.communication.azure.com
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        super(endpoint, options);
        this.sms = new Sms(this);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const SDK_VERSION = "1.0.0";

// Copyright (c) Microsoft Corporation.
/**
 * Creates a span using the global tracer.
 * @internal
 */
const createSpan = coreTracing.createSpanFunction({
    packagePrefix: "Azure.Communication",
    namespace: "Microsoft.Communication"
});

// Copyright (c) Microsoft Corporation.
/**
 * The \@azure/logger configuration for this package.
 */
const logger = logger$1.createClientLogger("communication-sms");

// Copyright (c) Microsoft Corporation.
const extractOperationOptions = (obj) => {
    const { abortSignal, requestOptions, tracingOptions } = obj, restOptions = tslib.__rest(obj, ["abortSignal", "requestOptions", "tracingOptions"]);
    return {
        operationOptions: {
            abortSignal,
            requestOptions,
            tracingOptions
        },
        restOptions
    };
};

// Copyright (c) Microsoft Corporation.
// This is used as a workaround to be able to stub generateUuid
// during testing.
class Uuid {
    static generateUuid() {
        return coreHttp.generateUuid();
    }
}

// Copyright (c) Microsoft Corporation.
function generateSendMessageRequest(smsRequest, options = {}) {
    var _a, _b;
    const _smsSendOptions = {
        enableDeliveryReport: (_a = options.enableDeliveryReport) !== null && _a !== void 0 ? _a : false
    };
    if (options.tag) {
        _smsSendOptions["tag"] = options.tag;
    }
    return {
        from: smsRequest.from,
        smsRecipients: smsRequest.to.map((phoneNumberStr) => {
            return {
                to: phoneNumberStr,
                repeatabilityFirstSent: new Date(Date.now()).toUTCString(),
                repeatabilityRequestId: Uuid.generateUuid()
            };
        }),
        message: smsRequest.message,
        smsSendOptions: Object.assign({ enableDeliveryReport: (_b = options.enableDeliveryReport) !== null && _b !== void 0 ? _b : false }, (options.tag && { tag: options.tag }))
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Checks whether the type of a value is SmsClientOptions or not.
 *
 * @param options - The value being checked.
 */
const isSmsClientOptions = (options) => !!options && !communicationCommon.isKeyCredential(options);
/**
 * A SmsClient represents a Client to the Azure Communication Sms service allowing you
 * to send SMS messages.
 */
class SmsClient {
    constructor(connectionStringOrUrl, credentialOrOptions, maybeOptions = {}) {
        const { url, credential } = communicationCommon.parseClientArguments(connectionStringOrUrl, credentialOrOptions);
        const options = isSmsClientOptions(credentialOrOptions) ? credentialOrOptions : maybeOptions;
        const libInfo = `azsdk-js-communication-sms/${SDK_VERSION}`;
        if (!options.userAgentOptions) {
            options.userAgentOptions = {};
        }
        if (options.userAgentOptions.userAgentPrefix) {
            options.userAgentOptions.userAgentPrefix = `${options.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            options.userAgentOptions.userAgentPrefix = libInfo;
        }
        const internalPipelineOptions = Object.assign(Object.assign({}, options), {
            loggingOptions: {
                logger: logger.info
            }
        });
        const authPolicy = communicationCommon.createCommunicationAuthPolicy(credential);
        const pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.api = new SmsApiClient(url, pipeline);
    }
    /**
     * Sends an SMS from a phone number that is acquired by the authenticated account, to another phone number.
     *
     * @param sendRequest - Provides the sender's and recipient's phone numbers, and the contents of the message
     * @param options - Additional request options
     */
    send(sendRequest, options = { enableDeliveryReport: false }) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { operationOptions, restOptions } = extractOperationOptions(options);
            const { span, updatedOptions } = createSpan("SmsClient-Send", operationOptions);
            try {
                const response = yield this.api.sms.send(generateSendMessageRequest(sendRequest, restOptions), coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                return response.value;
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
}

exports.SmsClient = SmsClient;
//# sourceMappingURL=index.js.map
